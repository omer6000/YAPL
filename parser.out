Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    PRINT

Grammar

Rule 0     S' -> calc
Rule 1     calc -> assignment SEMICOLON
Rule 2     calc -> assignment SEMICOLON calc
Rule 3     calc -> declaration SEMICOLON
Rule 4     calc -> declaration SEMICOLON calc
Rule 5     calc -> variable_update SEMICOLON
Rule 6     calc -> variable_update SEMICOLON calc
Rule 7     var -> NAME
Rule 8     declaration -> DOUBLE_TYPE NAME
Rule 9     declaration -> INT_TYPE NAME
Rule 10    declaration -> STRING_TYPE NAME
Rule 11    declaration -> CHARACTER_TYPE NAME
Rule 12    declaration -> BOOL_TYPE NAME
Rule 13    declaration -> empty
Rule 14    assignment -> DOUBLE_TYPE NAME ASSIGNMENT double_expression
Rule 15    assignment -> INT_TYPE NAME ASSIGNMENT int_expression
Rule 16    assignment -> STRING_TYPE NAME ASSIGNMENT string_expression
Rule 17    assignment -> CHARACTER_TYPE NAME ASSIGNMENT CHAR
Rule 18    assignment -> BOOL_TYPE NAME ASSIGNMENT BOOL
Rule 19    assignment -> empty
Rule 20    variable_update -> NAME ASSIGNMENT double_expression
Rule 21    variable_update -> NAME ASSIGNMENT int_expression
Rule 22    variable_update -> NAME ASSIGNMENT string_expression
Rule 23    variable_update -> NAME ASSIGNMENT CHAR
Rule 24    variable_update -> NAME ASSIGNMENT BOOL
Rule 25    double_expression -> double_expression PLUS double_expression
Rule 26    double_expression -> double_expression MINUS double_expression
Rule 27    double_expression -> double_expression MULTIPLY double_expression
Rule 28    double_expression -> double_expression DIVIDE double_expression
Rule 29    double_expression -> DOUBLE
Rule 30    double_expression -> var
Rule 31    int_expression -> int_expression PLUS int_expression
Rule 32    int_expression -> int_expression MINUS int_expression
Rule 33    int_expression -> int_expression MULTIPLY int_expression
Rule 34    int_expression -> int_expression DIVIDE int_expression
Rule 35    int_expression -> INT
Rule 36    int_expression -> var
Rule 37    string_expression -> string_expression PLUS string_expression
Rule 38    string_expression -> STRING
Rule 39    string_expression -> var
Rule 40    empty -> <empty>

Terminals, with rules where they appear

ASSIGNMENT           : 14 15 16 17 18 20 21 22 23 24
BOOL                 : 18 24
BOOL_TYPE            : 12 18
CHAR                 : 17 23
CHARACTER_TYPE       : 11 17
DIVIDE               : 28 34
DOUBLE               : 29
DOUBLE_TYPE          : 8 14
INT                  : 35
INT_TYPE             : 9 15
MINUS                : 26 32
MULTIPLY             : 27 33
NAME                 : 7 8 9 10 11 12 14 15 16 17 18 20 21 22 23 24
PLUS                 : 25 31 37
PRINT                : 
SEMICOLON            : 1 2 3 4 5 6
STRING               : 38
STRING_TYPE          : 10 16
error                : 

Nonterminals, with rules where they appear

assignment           : 1 2
calc                 : 2 4 6 0
declaration          : 3 4
double_expression    : 14 20 25 25 26 26 27 27 28 28
empty                : 13 19
int_expression       : 15 21 31 31 32 32 33 33 34 34
string_expression    : 16 22 37 37
var                  : 30 36 39
variable_update      : 5 6

Parsing method: LALR

state 0

    (0) S' -> . calc
    (1) calc -> . assignment SEMICOLON
    (2) calc -> . assignment SEMICOLON calc
    (3) calc -> . declaration SEMICOLON
    (4) calc -> . declaration SEMICOLON calc
    (5) calc -> . variable_update SEMICOLON
    (6) calc -> . variable_update SEMICOLON calc
    (14) assignment -> . DOUBLE_TYPE NAME ASSIGNMENT double_expression
    (15) assignment -> . INT_TYPE NAME ASSIGNMENT int_expression
    (16) assignment -> . STRING_TYPE NAME ASSIGNMENT string_expression
    (17) assignment -> . CHARACTER_TYPE NAME ASSIGNMENT CHAR
    (18) assignment -> . BOOL_TYPE NAME ASSIGNMENT BOOL
    (19) assignment -> . empty
    (8) declaration -> . DOUBLE_TYPE NAME
    (9) declaration -> . INT_TYPE NAME
    (10) declaration -> . STRING_TYPE NAME
    (11) declaration -> . CHARACTER_TYPE NAME
    (12) declaration -> . BOOL_TYPE NAME
    (13) declaration -> . empty
    (20) variable_update -> . NAME ASSIGNMENT double_expression
    (21) variable_update -> . NAME ASSIGNMENT int_expression
    (22) variable_update -> . NAME ASSIGNMENT string_expression
    (23) variable_update -> . NAME ASSIGNMENT CHAR
    (24) variable_update -> . NAME ASSIGNMENT BOOL
    (40) empty -> .

    DOUBLE_TYPE     shift and go to state 5
    INT_TYPE        shift and go to state 7
    STRING_TYPE     shift and go to state 8
    CHARACTER_TYPE  shift and go to state 9
    BOOL_TYPE       shift and go to state 10
    NAME            shift and go to state 6
    SEMICOLON       reduce using rule 40 (empty -> .)

    calc                           shift and go to state 1
    assignment                     shift and go to state 2
    declaration                    shift and go to state 3
    variable_update                shift and go to state 4
    empty                          shift and go to state 11

state 1

    (0) S' -> calc .



state 2

    (1) calc -> assignment . SEMICOLON
    (2) calc -> assignment . SEMICOLON calc

    SEMICOLON       shift and go to state 12


state 3

    (3) calc -> declaration . SEMICOLON
    (4) calc -> declaration . SEMICOLON calc

    SEMICOLON       shift and go to state 13


state 4

    (5) calc -> variable_update . SEMICOLON
    (6) calc -> variable_update . SEMICOLON calc

    SEMICOLON       shift and go to state 14


state 5

    (14) assignment -> DOUBLE_TYPE . NAME ASSIGNMENT double_expression
    (8) declaration -> DOUBLE_TYPE . NAME

    NAME            shift and go to state 15


state 6

    (20) variable_update -> NAME . ASSIGNMENT double_expression
    (21) variable_update -> NAME . ASSIGNMENT int_expression
    (22) variable_update -> NAME . ASSIGNMENT string_expression
    (23) variable_update -> NAME . ASSIGNMENT CHAR
    (24) variable_update -> NAME . ASSIGNMENT BOOL

    ASSIGNMENT      shift and go to state 16


state 7

    (15) assignment -> INT_TYPE . NAME ASSIGNMENT int_expression
    (9) declaration -> INT_TYPE . NAME

    NAME            shift and go to state 17


state 8

    (16) assignment -> STRING_TYPE . NAME ASSIGNMENT string_expression
    (10) declaration -> STRING_TYPE . NAME

    NAME            shift and go to state 18


state 9

    (17) assignment -> CHARACTER_TYPE . NAME ASSIGNMENT CHAR
    (11) declaration -> CHARACTER_TYPE . NAME

    NAME            shift and go to state 19


state 10

    (18) assignment -> BOOL_TYPE . NAME ASSIGNMENT BOOL
    (12) declaration -> BOOL_TYPE . NAME

    NAME            shift and go to state 20


state 11

    (19) assignment -> empty .
    (13) declaration -> empty .

  ! reduce/reduce conflict for SEMICOLON resolved using rule 13 (declaration -> empty .)
    SEMICOLON       reduce using rule 13 (declaration -> empty .)

  ! SEMICOLON       [ reduce using rule 19 (assignment -> empty .) ]


state 12

    (1) calc -> assignment SEMICOLON .
    (2) calc -> assignment SEMICOLON . calc
    (1) calc -> . assignment SEMICOLON
    (2) calc -> . assignment SEMICOLON calc
    (3) calc -> . declaration SEMICOLON
    (4) calc -> . declaration SEMICOLON calc
    (5) calc -> . variable_update SEMICOLON
    (6) calc -> . variable_update SEMICOLON calc
    (14) assignment -> . DOUBLE_TYPE NAME ASSIGNMENT double_expression
    (15) assignment -> . INT_TYPE NAME ASSIGNMENT int_expression
    (16) assignment -> . STRING_TYPE NAME ASSIGNMENT string_expression
    (17) assignment -> . CHARACTER_TYPE NAME ASSIGNMENT CHAR
    (18) assignment -> . BOOL_TYPE NAME ASSIGNMENT BOOL
    (19) assignment -> . empty
    (8) declaration -> . DOUBLE_TYPE NAME
    (9) declaration -> . INT_TYPE NAME
    (10) declaration -> . STRING_TYPE NAME
    (11) declaration -> . CHARACTER_TYPE NAME
    (12) declaration -> . BOOL_TYPE NAME
    (13) declaration -> . empty
    (20) variable_update -> . NAME ASSIGNMENT double_expression
    (21) variable_update -> . NAME ASSIGNMENT int_expression
    (22) variable_update -> . NAME ASSIGNMENT string_expression
    (23) variable_update -> . NAME ASSIGNMENT CHAR
    (24) variable_update -> . NAME ASSIGNMENT BOOL
    (40) empty -> .

    $end            reduce using rule 1 (calc -> assignment SEMICOLON .)
    DOUBLE_TYPE     shift and go to state 5
    INT_TYPE        shift and go to state 7
    STRING_TYPE     shift and go to state 8
    CHARACTER_TYPE  shift and go to state 9
    BOOL_TYPE       shift and go to state 10
    NAME            shift and go to state 6
    SEMICOLON       reduce using rule 40 (empty -> .)

    assignment                     shift and go to state 2
    calc                           shift and go to state 21
    declaration                    shift and go to state 3
    variable_update                shift and go to state 4
    empty                          shift and go to state 11

state 13

    (3) calc -> declaration SEMICOLON .
    (4) calc -> declaration SEMICOLON . calc
    (1) calc -> . assignment SEMICOLON
    (2) calc -> . assignment SEMICOLON calc
    (3) calc -> . declaration SEMICOLON
    (4) calc -> . declaration SEMICOLON calc
    (5) calc -> . variable_update SEMICOLON
    (6) calc -> . variable_update SEMICOLON calc
    (14) assignment -> . DOUBLE_TYPE NAME ASSIGNMENT double_expression
    (15) assignment -> . INT_TYPE NAME ASSIGNMENT int_expression
    (16) assignment -> . STRING_TYPE NAME ASSIGNMENT string_expression
    (17) assignment -> . CHARACTER_TYPE NAME ASSIGNMENT CHAR
    (18) assignment -> . BOOL_TYPE NAME ASSIGNMENT BOOL
    (19) assignment -> . empty
    (8) declaration -> . DOUBLE_TYPE NAME
    (9) declaration -> . INT_TYPE NAME
    (10) declaration -> . STRING_TYPE NAME
    (11) declaration -> . CHARACTER_TYPE NAME
    (12) declaration -> . BOOL_TYPE NAME
    (13) declaration -> . empty
    (20) variable_update -> . NAME ASSIGNMENT double_expression
    (21) variable_update -> . NAME ASSIGNMENT int_expression
    (22) variable_update -> . NAME ASSIGNMENT string_expression
    (23) variable_update -> . NAME ASSIGNMENT CHAR
    (24) variable_update -> . NAME ASSIGNMENT BOOL
    (40) empty -> .

    $end            reduce using rule 3 (calc -> declaration SEMICOLON .)
    DOUBLE_TYPE     shift and go to state 5
    INT_TYPE        shift and go to state 7
    STRING_TYPE     shift and go to state 8
    CHARACTER_TYPE  shift and go to state 9
    BOOL_TYPE       shift and go to state 10
    NAME            shift and go to state 6
    SEMICOLON       reduce using rule 40 (empty -> .)

    declaration                    shift and go to state 3
    calc                           shift and go to state 22
    assignment                     shift and go to state 2
    variable_update                shift and go to state 4
    empty                          shift and go to state 11

state 14

    (5) calc -> variable_update SEMICOLON .
    (6) calc -> variable_update SEMICOLON . calc
    (1) calc -> . assignment SEMICOLON
    (2) calc -> . assignment SEMICOLON calc
    (3) calc -> . declaration SEMICOLON
    (4) calc -> . declaration SEMICOLON calc
    (5) calc -> . variable_update SEMICOLON
    (6) calc -> . variable_update SEMICOLON calc
    (14) assignment -> . DOUBLE_TYPE NAME ASSIGNMENT double_expression
    (15) assignment -> . INT_TYPE NAME ASSIGNMENT int_expression
    (16) assignment -> . STRING_TYPE NAME ASSIGNMENT string_expression
    (17) assignment -> . CHARACTER_TYPE NAME ASSIGNMENT CHAR
    (18) assignment -> . BOOL_TYPE NAME ASSIGNMENT BOOL
    (19) assignment -> . empty
    (8) declaration -> . DOUBLE_TYPE NAME
    (9) declaration -> . INT_TYPE NAME
    (10) declaration -> . STRING_TYPE NAME
    (11) declaration -> . CHARACTER_TYPE NAME
    (12) declaration -> . BOOL_TYPE NAME
    (13) declaration -> . empty
    (20) variable_update -> . NAME ASSIGNMENT double_expression
    (21) variable_update -> . NAME ASSIGNMENT int_expression
    (22) variable_update -> . NAME ASSIGNMENT string_expression
    (23) variable_update -> . NAME ASSIGNMENT CHAR
    (24) variable_update -> . NAME ASSIGNMENT BOOL
    (40) empty -> .

    $end            reduce using rule 5 (calc -> variable_update SEMICOLON .)
    DOUBLE_TYPE     shift and go to state 5
    INT_TYPE        shift and go to state 7
    STRING_TYPE     shift and go to state 8
    CHARACTER_TYPE  shift and go to state 9
    BOOL_TYPE       shift and go to state 10
    NAME            shift and go to state 6
    SEMICOLON       reduce using rule 40 (empty -> .)

    variable_update                shift and go to state 4
    calc                           shift and go to state 23
    assignment                     shift and go to state 2
    declaration                    shift and go to state 3
    empty                          shift and go to state 11

state 15

    (14) assignment -> DOUBLE_TYPE NAME . ASSIGNMENT double_expression
    (8) declaration -> DOUBLE_TYPE NAME .

    ASSIGNMENT      shift and go to state 24
    SEMICOLON       reduce using rule 8 (declaration -> DOUBLE_TYPE NAME .)


state 16

    (20) variable_update -> NAME ASSIGNMENT . double_expression
    (21) variable_update -> NAME ASSIGNMENT . int_expression
    (22) variable_update -> NAME ASSIGNMENT . string_expression
    (23) variable_update -> NAME ASSIGNMENT . CHAR
    (24) variable_update -> NAME ASSIGNMENT . BOOL
    (25) double_expression -> . double_expression PLUS double_expression
    (26) double_expression -> . double_expression MINUS double_expression
    (27) double_expression -> . double_expression MULTIPLY double_expression
    (28) double_expression -> . double_expression DIVIDE double_expression
    (29) double_expression -> . DOUBLE
    (30) double_expression -> . var
    (31) int_expression -> . int_expression PLUS int_expression
    (32) int_expression -> . int_expression MINUS int_expression
    (33) int_expression -> . int_expression MULTIPLY int_expression
    (34) int_expression -> . int_expression DIVIDE int_expression
    (35) int_expression -> . INT
    (36) int_expression -> . var
    (37) string_expression -> . string_expression PLUS string_expression
    (38) string_expression -> . STRING
    (39) string_expression -> . var
    (7) var -> . NAME

    CHAR            shift and go to state 29
    BOOL            shift and go to state 30
    DOUBLE          shift and go to state 31
    INT             shift and go to state 33
    STRING          shift and go to state 34
    NAME            shift and go to state 25

    double_expression              shift and go to state 26
    int_expression                 shift and go to state 27
    string_expression              shift and go to state 28
    var                            shift and go to state 32

state 17

    (15) assignment -> INT_TYPE NAME . ASSIGNMENT int_expression
    (9) declaration -> INT_TYPE NAME .

    ASSIGNMENT      shift and go to state 35
    SEMICOLON       reduce using rule 9 (declaration -> INT_TYPE NAME .)


state 18

    (16) assignment -> STRING_TYPE NAME . ASSIGNMENT string_expression
    (10) declaration -> STRING_TYPE NAME .

    ASSIGNMENT      shift and go to state 36
    SEMICOLON       reduce using rule 10 (declaration -> STRING_TYPE NAME .)


state 19

    (17) assignment -> CHARACTER_TYPE NAME . ASSIGNMENT CHAR
    (11) declaration -> CHARACTER_TYPE NAME .

    ASSIGNMENT      shift and go to state 37
    SEMICOLON       reduce using rule 11 (declaration -> CHARACTER_TYPE NAME .)


state 20

    (18) assignment -> BOOL_TYPE NAME . ASSIGNMENT BOOL
    (12) declaration -> BOOL_TYPE NAME .

    ASSIGNMENT      shift and go to state 38
    SEMICOLON       reduce using rule 12 (declaration -> BOOL_TYPE NAME .)


state 21

    (2) calc -> assignment SEMICOLON calc .

    $end            reduce using rule 2 (calc -> assignment SEMICOLON calc .)


state 22

    (4) calc -> declaration SEMICOLON calc .

    $end            reduce using rule 4 (calc -> declaration SEMICOLON calc .)


state 23

    (6) calc -> variable_update SEMICOLON calc .

    $end            reduce using rule 6 (calc -> variable_update SEMICOLON calc .)


state 24

    (14) assignment -> DOUBLE_TYPE NAME ASSIGNMENT . double_expression
    (25) double_expression -> . double_expression PLUS double_expression
    (26) double_expression -> . double_expression MINUS double_expression
    (27) double_expression -> . double_expression MULTIPLY double_expression
    (28) double_expression -> . double_expression DIVIDE double_expression
    (29) double_expression -> . DOUBLE
    (30) double_expression -> . var
    (7) var -> . NAME

    DOUBLE          shift and go to state 31
    NAME            shift and go to state 25

    double_expression              shift and go to state 39
    var                            shift and go to state 40

state 25

    (7) var -> NAME .

    PLUS            reduce using rule 7 (var -> NAME .)
    MINUS           reduce using rule 7 (var -> NAME .)
    MULTIPLY        reduce using rule 7 (var -> NAME .)
    DIVIDE          reduce using rule 7 (var -> NAME .)
    SEMICOLON       reduce using rule 7 (var -> NAME .)


state 26

    (20) variable_update -> NAME ASSIGNMENT double_expression .
    (25) double_expression -> double_expression . PLUS double_expression
    (26) double_expression -> double_expression . MINUS double_expression
    (27) double_expression -> double_expression . MULTIPLY double_expression
    (28) double_expression -> double_expression . DIVIDE double_expression

    SEMICOLON       reduce using rule 20 (variable_update -> NAME ASSIGNMENT double_expression .)
    PLUS            shift and go to state 41
    MINUS           shift and go to state 42
    MULTIPLY        shift and go to state 43
    DIVIDE          shift and go to state 44


state 27

    (21) variable_update -> NAME ASSIGNMENT int_expression .
    (31) int_expression -> int_expression . PLUS int_expression
    (32) int_expression -> int_expression . MINUS int_expression
    (33) int_expression -> int_expression . MULTIPLY int_expression
    (34) int_expression -> int_expression . DIVIDE int_expression

    SEMICOLON       reduce using rule 21 (variable_update -> NAME ASSIGNMENT int_expression .)
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46
    MULTIPLY        shift and go to state 47
    DIVIDE          shift and go to state 48


state 28

    (22) variable_update -> NAME ASSIGNMENT string_expression .
    (37) string_expression -> string_expression . PLUS string_expression

    SEMICOLON       reduce using rule 22 (variable_update -> NAME ASSIGNMENT string_expression .)
    PLUS            shift and go to state 49


state 29

    (23) variable_update -> NAME ASSIGNMENT CHAR .

    SEMICOLON       reduce using rule 23 (variable_update -> NAME ASSIGNMENT CHAR .)


state 30

    (24) variable_update -> NAME ASSIGNMENT BOOL .

    SEMICOLON       reduce using rule 24 (variable_update -> NAME ASSIGNMENT BOOL .)


state 31

    (29) double_expression -> DOUBLE .

    PLUS            reduce using rule 29 (double_expression -> DOUBLE .)
    MINUS           reduce using rule 29 (double_expression -> DOUBLE .)
    MULTIPLY        reduce using rule 29 (double_expression -> DOUBLE .)
    DIVIDE          reduce using rule 29 (double_expression -> DOUBLE .)
    SEMICOLON       reduce using rule 29 (double_expression -> DOUBLE .)


state 32

    (30) double_expression -> var .
    (36) int_expression -> var .
    (39) string_expression -> var .

  ! reduce/reduce conflict for PLUS resolved using rule 30 (double_expression -> var .)
  ! reduce/reduce conflict for MINUS resolved using rule 30 (double_expression -> var .)
  ! reduce/reduce conflict for MULTIPLY resolved using rule 30 (double_expression -> var .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 30 (double_expression -> var .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 30 (double_expression -> var .)
  ! reduce/reduce conflict for PLUS resolved using rule 30 (double_expression -> var .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 30 (double_expression -> var .)
    PLUS            reduce using rule 30 (double_expression -> var .)
    MINUS           reduce using rule 30 (double_expression -> var .)
    MULTIPLY        reduce using rule 30 (double_expression -> var .)
    DIVIDE          reduce using rule 30 (double_expression -> var .)
    SEMICOLON       reduce using rule 30 (double_expression -> var .)

  ! PLUS            [ reduce using rule 36 (int_expression -> var .) ]
  ! MINUS           [ reduce using rule 36 (int_expression -> var .) ]
  ! MULTIPLY        [ reduce using rule 36 (int_expression -> var .) ]
  ! DIVIDE          [ reduce using rule 36 (int_expression -> var .) ]
  ! SEMICOLON       [ reduce using rule 36 (int_expression -> var .) ]
  ! PLUS            [ reduce using rule 39 (string_expression -> var .) ]
  ! SEMICOLON       [ reduce using rule 39 (string_expression -> var .) ]


state 33

    (35) int_expression -> INT .

    PLUS            reduce using rule 35 (int_expression -> INT .)
    MINUS           reduce using rule 35 (int_expression -> INT .)
    MULTIPLY        reduce using rule 35 (int_expression -> INT .)
    DIVIDE          reduce using rule 35 (int_expression -> INT .)
    SEMICOLON       reduce using rule 35 (int_expression -> INT .)


state 34

    (38) string_expression -> STRING .

    PLUS            reduce using rule 38 (string_expression -> STRING .)
    SEMICOLON       reduce using rule 38 (string_expression -> STRING .)


state 35

    (15) assignment -> INT_TYPE NAME ASSIGNMENT . int_expression
    (31) int_expression -> . int_expression PLUS int_expression
    (32) int_expression -> . int_expression MINUS int_expression
    (33) int_expression -> . int_expression MULTIPLY int_expression
    (34) int_expression -> . int_expression DIVIDE int_expression
    (35) int_expression -> . INT
    (36) int_expression -> . var
    (7) var -> . NAME

    INT             shift and go to state 33
    NAME            shift and go to state 25

    int_expression                 shift and go to state 50
    var                            shift and go to state 51

state 36

    (16) assignment -> STRING_TYPE NAME ASSIGNMENT . string_expression
    (37) string_expression -> . string_expression PLUS string_expression
    (38) string_expression -> . STRING
    (39) string_expression -> . var
    (7) var -> . NAME

    STRING          shift and go to state 34
    NAME            shift and go to state 25

    string_expression              shift and go to state 52
    var                            shift and go to state 53

state 37

    (17) assignment -> CHARACTER_TYPE NAME ASSIGNMENT . CHAR

    CHAR            shift and go to state 54


state 38

    (18) assignment -> BOOL_TYPE NAME ASSIGNMENT . BOOL

    BOOL            shift and go to state 55


state 39

    (14) assignment -> DOUBLE_TYPE NAME ASSIGNMENT double_expression .
    (25) double_expression -> double_expression . PLUS double_expression
    (26) double_expression -> double_expression . MINUS double_expression
    (27) double_expression -> double_expression . MULTIPLY double_expression
    (28) double_expression -> double_expression . DIVIDE double_expression

    SEMICOLON       reduce using rule 14 (assignment -> DOUBLE_TYPE NAME ASSIGNMENT double_expression .)
    PLUS            shift and go to state 41
    MINUS           shift and go to state 42
    MULTIPLY        shift and go to state 43
    DIVIDE          shift and go to state 44


state 40

    (30) double_expression -> var .

    PLUS            reduce using rule 30 (double_expression -> var .)
    MINUS           reduce using rule 30 (double_expression -> var .)
    MULTIPLY        reduce using rule 30 (double_expression -> var .)
    DIVIDE          reduce using rule 30 (double_expression -> var .)
    SEMICOLON       reduce using rule 30 (double_expression -> var .)


state 41

    (25) double_expression -> double_expression PLUS . double_expression
    (25) double_expression -> . double_expression PLUS double_expression
    (26) double_expression -> . double_expression MINUS double_expression
    (27) double_expression -> . double_expression MULTIPLY double_expression
    (28) double_expression -> . double_expression DIVIDE double_expression
    (29) double_expression -> . DOUBLE
    (30) double_expression -> . var
    (7) var -> . NAME

    DOUBLE          shift and go to state 31
    NAME            shift and go to state 25

    double_expression              shift and go to state 56
    var                            shift and go to state 40

state 42

    (26) double_expression -> double_expression MINUS . double_expression
    (25) double_expression -> . double_expression PLUS double_expression
    (26) double_expression -> . double_expression MINUS double_expression
    (27) double_expression -> . double_expression MULTIPLY double_expression
    (28) double_expression -> . double_expression DIVIDE double_expression
    (29) double_expression -> . DOUBLE
    (30) double_expression -> . var
    (7) var -> . NAME

    DOUBLE          shift and go to state 31
    NAME            shift and go to state 25

    double_expression              shift and go to state 57
    var                            shift and go to state 40

state 43

    (27) double_expression -> double_expression MULTIPLY . double_expression
    (25) double_expression -> . double_expression PLUS double_expression
    (26) double_expression -> . double_expression MINUS double_expression
    (27) double_expression -> . double_expression MULTIPLY double_expression
    (28) double_expression -> . double_expression DIVIDE double_expression
    (29) double_expression -> . DOUBLE
    (30) double_expression -> . var
    (7) var -> . NAME

    DOUBLE          shift and go to state 31
    NAME            shift and go to state 25

    double_expression              shift and go to state 58
    var                            shift and go to state 40

state 44

    (28) double_expression -> double_expression DIVIDE . double_expression
    (25) double_expression -> . double_expression PLUS double_expression
    (26) double_expression -> . double_expression MINUS double_expression
    (27) double_expression -> . double_expression MULTIPLY double_expression
    (28) double_expression -> . double_expression DIVIDE double_expression
    (29) double_expression -> . DOUBLE
    (30) double_expression -> . var
    (7) var -> . NAME

    DOUBLE          shift and go to state 31
    NAME            shift and go to state 25

    double_expression              shift and go to state 59
    var                            shift and go to state 40

state 45

    (31) int_expression -> int_expression PLUS . int_expression
    (31) int_expression -> . int_expression PLUS int_expression
    (32) int_expression -> . int_expression MINUS int_expression
    (33) int_expression -> . int_expression MULTIPLY int_expression
    (34) int_expression -> . int_expression DIVIDE int_expression
    (35) int_expression -> . INT
    (36) int_expression -> . var
    (7) var -> . NAME

    INT             shift and go to state 33
    NAME            shift and go to state 25

    int_expression                 shift and go to state 60
    var                            shift and go to state 51

state 46

    (32) int_expression -> int_expression MINUS . int_expression
    (31) int_expression -> . int_expression PLUS int_expression
    (32) int_expression -> . int_expression MINUS int_expression
    (33) int_expression -> . int_expression MULTIPLY int_expression
    (34) int_expression -> . int_expression DIVIDE int_expression
    (35) int_expression -> . INT
    (36) int_expression -> . var
    (7) var -> . NAME

    INT             shift and go to state 33
    NAME            shift and go to state 25

    int_expression                 shift and go to state 61
    var                            shift and go to state 51

state 47

    (33) int_expression -> int_expression MULTIPLY . int_expression
    (31) int_expression -> . int_expression PLUS int_expression
    (32) int_expression -> . int_expression MINUS int_expression
    (33) int_expression -> . int_expression MULTIPLY int_expression
    (34) int_expression -> . int_expression DIVIDE int_expression
    (35) int_expression -> . INT
    (36) int_expression -> . var
    (7) var -> . NAME

    INT             shift and go to state 33
    NAME            shift and go to state 25

    int_expression                 shift and go to state 62
    var                            shift and go to state 51

state 48

    (34) int_expression -> int_expression DIVIDE . int_expression
    (31) int_expression -> . int_expression PLUS int_expression
    (32) int_expression -> . int_expression MINUS int_expression
    (33) int_expression -> . int_expression MULTIPLY int_expression
    (34) int_expression -> . int_expression DIVIDE int_expression
    (35) int_expression -> . INT
    (36) int_expression -> . var
    (7) var -> . NAME

    INT             shift and go to state 33
    NAME            shift and go to state 25

    int_expression                 shift and go to state 63
    var                            shift and go to state 51

state 49

    (37) string_expression -> string_expression PLUS . string_expression
    (37) string_expression -> . string_expression PLUS string_expression
    (38) string_expression -> . STRING
    (39) string_expression -> . var
    (7) var -> . NAME

    STRING          shift and go to state 34
    NAME            shift and go to state 25

    string_expression              shift and go to state 64
    var                            shift and go to state 53

state 50

    (15) assignment -> INT_TYPE NAME ASSIGNMENT int_expression .
    (31) int_expression -> int_expression . PLUS int_expression
    (32) int_expression -> int_expression . MINUS int_expression
    (33) int_expression -> int_expression . MULTIPLY int_expression
    (34) int_expression -> int_expression . DIVIDE int_expression

    SEMICOLON       reduce using rule 15 (assignment -> INT_TYPE NAME ASSIGNMENT int_expression .)
    PLUS            shift and go to state 45
    MINUS           shift and go to state 46
    MULTIPLY        shift and go to state 47
    DIVIDE          shift and go to state 48


state 51

    (36) int_expression -> var .

    PLUS            reduce using rule 36 (int_expression -> var .)
    MINUS           reduce using rule 36 (int_expression -> var .)
    MULTIPLY        reduce using rule 36 (int_expression -> var .)
    DIVIDE          reduce using rule 36 (int_expression -> var .)
    SEMICOLON       reduce using rule 36 (int_expression -> var .)


state 52

    (16) assignment -> STRING_TYPE NAME ASSIGNMENT string_expression .
    (37) string_expression -> string_expression . PLUS string_expression

    SEMICOLON       reduce using rule 16 (assignment -> STRING_TYPE NAME ASSIGNMENT string_expression .)
    PLUS            shift and go to state 49


state 53

    (39) string_expression -> var .

    PLUS            reduce using rule 39 (string_expression -> var .)
    SEMICOLON       reduce using rule 39 (string_expression -> var .)


state 54

    (17) assignment -> CHARACTER_TYPE NAME ASSIGNMENT CHAR .

    SEMICOLON       reduce using rule 17 (assignment -> CHARACTER_TYPE NAME ASSIGNMENT CHAR .)


state 55

    (18) assignment -> BOOL_TYPE NAME ASSIGNMENT BOOL .

    SEMICOLON       reduce using rule 18 (assignment -> BOOL_TYPE NAME ASSIGNMENT BOOL .)


state 56

    (25) double_expression -> double_expression PLUS double_expression .
    (25) double_expression -> double_expression . PLUS double_expression
    (26) double_expression -> double_expression . MINUS double_expression
    (27) double_expression -> double_expression . MULTIPLY double_expression
    (28) double_expression -> double_expression . DIVIDE double_expression

    PLUS            reduce using rule 25 (double_expression -> double_expression PLUS double_expression .)
    MINUS           reduce using rule 25 (double_expression -> double_expression PLUS double_expression .)
    SEMICOLON       reduce using rule 25 (double_expression -> double_expression PLUS double_expression .)
    MULTIPLY        shift and go to state 43
    DIVIDE          shift and go to state 44

  ! MULTIPLY        [ reduce using rule 25 (double_expression -> double_expression PLUS double_expression .) ]
  ! DIVIDE          [ reduce using rule 25 (double_expression -> double_expression PLUS double_expression .) ]
  ! PLUS            [ shift and go to state 41 ]
  ! MINUS           [ shift and go to state 42 ]


state 57

    (26) double_expression -> double_expression MINUS double_expression .
    (25) double_expression -> double_expression . PLUS double_expression
    (26) double_expression -> double_expression . MINUS double_expression
    (27) double_expression -> double_expression . MULTIPLY double_expression
    (28) double_expression -> double_expression . DIVIDE double_expression

    PLUS            reduce using rule 26 (double_expression -> double_expression MINUS double_expression .)
    MINUS           reduce using rule 26 (double_expression -> double_expression MINUS double_expression .)
    SEMICOLON       reduce using rule 26 (double_expression -> double_expression MINUS double_expression .)
    MULTIPLY        shift and go to state 43
    DIVIDE          shift and go to state 44

  ! MULTIPLY        [ reduce using rule 26 (double_expression -> double_expression MINUS double_expression .) ]
  ! DIVIDE          [ reduce using rule 26 (double_expression -> double_expression MINUS double_expression .) ]
  ! PLUS            [ shift and go to state 41 ]
  ! MINUS           [ shift and go to state 42 ]


state 58

    (27) double_expression -> double_expression MULTIPLY double_expression .
    (25) double_expression -> double_expression . PLUS double_expression
    (26) double_expression -> double_expression . MINUS double_expression
    (27) double_expression -> double_expression . MULTIPLY double_expression
    (28) double_expression -> double_expression . DIVIDE double_expression

    PLUS            reduce using rule 27 (double_expression -> double_expression MULTIPLY double_expression .)
    MINUS           reduce using rule 27 (double_expression -> double_expression MULTIPLY double_expression .)
    MULTIPLY        reduce using rule 27 (double_expression -> double_expression MULTIPLY double_expression .)
    DIVIDE          reduce using rule 27 (double_expression -> double_expression MULTIPLY double_expression .)
    SEMICOLON       reduce using rule 27 (double_expression -> double_expression MULTIPLY double_expression .)

  ! PLUS            [ shift and go to state 41 ]
  ! MINUS           [ shift and go to state 42 ]
  ! MULTIPLY        [ shift and go to state 43 ]
  ! DIVIDE          [ shift and go to state 44 ]


state 59

    (28) double_expression -> double_expression DIVIDE double_expression .
    (25) double_expression -> double_expression . PLUS double_expression
    (26) double_expression -> double_expression . MINUS double_expression
    (27) double_expression -> double_expression . MULTIPLY double_expression
    (28) double_expression -> double_expression . DIVIDE double_expression

    PLUS            reduce using rule 28 (double_expression -> double_expression DIVIDE double_expression .)
    MINUS           reduce using rule 28 (double_expression -> double_expression DIVIDE double_expression .)
    MULTIPLY        reduce using rule 28 (double_expression -> double_expression DIVIDE double_expression .)
    DIVIDE          reduce using rule 28 (double_expression -> double_expression DIVIDE double_expression .)
    SEMICOLON       reduce using rule 28 (double_expression -> double_expression DIVIDE double_expression .)

  ! PLUS            [ shift and go to state 41 ]
  ! MINUS           [ shift and go to state 42 ]
  ! MULTIPLY        [ shift and go to state 43 ]
  ! DIVIDE          [ shift and go to state 44 ]


state 60

    (31) int_expression -> int_expression PLUS int_expression .
    (31) int_expression -> int_expression . PLUS int_expression
    (32) int_expression -> int_expression . MINUS int_expression
    (33) int_expression -> int_expression . MULTIPLY int_expression
    (34) int_expression -> int_expression . DIVIDE int_expression

    PLUS            reduce using rule 31 (int_expression -> int_expression PLUS int_expression .)
    MINUS           reduce using rule 31 (int_expression -> int_expression PLUS int_expression .)
    SEMICOLON       reduce using rule 31 (int_expression -> int_expression PLUS int_expression .)
    MULTIPLY        shift and go to state 47
    DIVIDE          shift and go to state 48

  ! MULTIPLY        [ reduce using rule 31 (int_expression -> int_expression PLUS int_expression .) ]
  ! DIVIDE          [ reduce using rule 31 (int_expression -> int_expression PLUS int_expression .) ]
  ! PLUS            [ shift and go to state 45 ]
  ! MINUS           [ shift and go to state 46 ]


state 61

    (32) int_expression -> int_expression MINUS int_expression .
    (31) int_expression -> int_expression . PLUS int_expression
    (32) int_expression -> int_expression . MINUS int_expression
    (33) int_expression -> int_expression . MULTIPLY int_expression
    (34) int_expression -> int_expression . DIVIDE int_expression

    PLUS            reduce using rule 32 (int_expression -> int_expression MINUS int_expression .)
    MINUS           reduce using rule 32 (int_expression -> int_expression MINUS int_expression .)
    SEMICOLON       reduce using rule 32 (int_expression -> int_expression MINUS int_expression .)
    MULTIPLY        shift and go to state 47
    DIVIDE          shift and go to state 48

  ! MULTIPLY        [ reduce using rule 32 (int_expression -> int_expression MINUS int_expression .) ]
  ! DIVIDE          [ reduce using rule 32 (int_expression -> int_expression MINUS int_expression .) ]
  ! PLUS            [ shift and go to state 45 ]
  ! MINUS           [ shift and go to state 46 ]


state 62

    (33) int_expression -> int_expression MULTIPLY int_expression .
    (31) int_expression -> int_expression . PLUS int_expression
    (32) int_expression -> int_expression . MINUS int_expression
    (33) int_expression -> int_expression . MULTIPLY int_expression
    (34) int_expression -> int_expression . DIVIDE int_expression

    PLUS            reduce using rule 33 (int_expression -> int_expression MULTIPLY int_expression .)
    MINUS           reduce using rule 33 (int_expression -> int_expression MULTIPLY int_expression .)
    MULTIPLY        reduce using rule 33 (int_expression -> int_expression MULTIPLY int_expression .)
    DIVIDE          reduce using rule 33 (int_expression -> int_expression MULTIPLY int_expression .)
    SEMICOLON       reduce using rule 33 (int_expression -> int_expression MULTIPLY int_expression .)

  ! PLUS            [ shift and go to state 45 ]
  ! MINUS           [ shift and go to state 46 ]
  ! MULTIPLY        [ shift and go to state 47 ]
  ! DIVIDE          [ shift and go to state 48 ]


state 63

    (34) int_expression -> int_expression DIVIDE int_expression .
    (31) int_expression -> int_expression . PLUS int_expression
    (32) int_expression -> int_expression . MINUS int_expression
    (33) int_expression -> int_expression . MULTIPLY int_expression
    (34) int_expression -> int_expression . DIVIDE int_expression

    PLUS            reduce using rule 34 (int_expression -> int_expression DIVIDE int_expression .)
    MINUS           reduce using rule 34 (int_expression -> int_expression DIVIDE int_expression .)
    MULTIPLY        reduce using rule 34 (int_expression -> int_expression DIVIDE int_expression .)
    DIVIDE          reduce using rule 34 (int_expression -> int_expression DIVIDE int_expression .)
    SEMICOLON       reduce using rule 34 (int_expression -> int_expression DIVIDE int_expression .)

  ! PLUS            [ shift and go to state 45 ]
  ! MINUS           [ shift and go to state 46 ]
  ! MULTIPLY        [ shift and go to state 47 ]
  ! DIVIDE          [ shift and go to state 48 ]


state 64

    (37) string_expression -> string_expression PLUS string_expression .
    (37) string_expression -> string_expression . PLUS string_expression

    PLUS            reduce using rule 37 (string_expression -> string_expression PLUS string_expression .)
    SEMICOLON       reduce using rule 37 (string_expression -> string_expression PLUS string_expression .)

  ! PLUS            [ shift and go to state 49 ]

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: reduce/reduce conflict in state 11 resolved using rule (declaration -> empty)
WARNING: rejected rule (assignment -> empty) in state 11
WARNING: reduce/reduce conflict in state 32 resolved using rule (double_expression -> var)
WARNING: rejected rule (int_expression -> var) in state 32
WARNING: reduce/reduce conflict in state 32 resolved using rule (double_expression -> var)
WARNING: rejected rule (string_expression -> var) in state 32
WARNING: Rule (assignment -> empty) is never reduced
